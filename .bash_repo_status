#!/usr/bin/env bash

# colors used in the prompt
COLOR_LIGHT_GRAY='\033[1;30m'
COLOR_RED='\033[0;31m'
COLOR_GREEN='\033[0;32m'
COLOR_LIGHT_BLUE='\033[1;34m'
COLOR_LIGHT_MAGENTA='\033[1;35m'
COLOR_ORANGE='\033[38;5;95;38;5;208m'
COLOR_RESET='\033[0m'

# git colors
GS_COLOR_GIT="$COLOR_LIGHT_BLUE"
GS_COLOR_BRANCH="$COLOR_LIGHT_BLUE"
GS_COLOR_NO_REMOTE="$COLOR_LIGHT_BLUE"
GS_COLOR_TAG="$COLOR_LIGHT_BLUE"
GS_COLOR_HASH="$COLOR_LIGHT_BLUE"
GS_COLOR_NEED_PUSH="$COLOR_LIGHT_BLUE"
GS_COLOR_NEED_PULL="$COLOR_LIGHT_BLUE"
GS_COLOR_FORK_AHEAD="$COLOR_LIGHT_BLUE"
GS_COLOR_FORK_BEHIND="$COLOR_LIGHT_BLUE"
GS_COLOR_REMOTE_OK="$COLOR_LIGHT_BLUE"
GS_COLOR_NEED_PUSH_UNTRACKED="$COLOR_LIGHT_BLUE"
GS_COLOR_CONFLICT="$COLOR_RED"
GS_COLOR_REBASE="$COLOR_RED"
GS_COLOR_MERGE="$COLOR_RED"
GS_COLOR_STAGED="$COLOR_GREEN"
GS_COLOR_LOCAL_OK="$COLOR_GREEN"
GS_COLOR_UNTRACKED="$COLOR_LIGHT_GRAY"
GS_COLOR_STASHED="$COLOR_LIGHT_MAGENTA"
GS_COLOR_BACKUP_REF="$COLOR_ORANGE"
GS_COLOR_MODIFIED="$COLOR_ORANGE"

# svn colors
RS_COLOR_SVN="$COLOR_LIGHT_BLUE"
RS_COLOR_SVN_PATH="$COLOR_LIGHT_BLUE"
RS_COLOR_SVN_REV="$COLOR_LIGHT_BLUE"
RS_COLOR_SVN_OK="$COLOR_GREEN"
RS_COLOR_SVN_DIRTY="$COLOR_RED"

# functions to set colors
function gs_color()  { echo "$1$2$COLOR_RESET"; }

# git symbols
GS_SYM_GIT='git'
GS_SYM_BRANCH='|'
GS_SYM_TAG='»'
GS_SYM_HASH='#'
GS_SYM_NO_REMOTE='-'
GS_SYM_NEED_PUSH='⇧'
GS_SYM_NEED_PULL='⇩'
GS_SYM_NEED_PUSH_UNTRACKED='⇪'
#GS_SYM_FORK='⑂'
GS_SYM_FORK='Ⴤ'
GS_SYM_REMOTE_OK='✓'
GS_SYM_STAGED='+'
GS_SYM_MODIFIED='*'
GS_SYM_UNTRACKED='?'
GS_SYM_CONFLICT='!'
GS_SYM_STASHED='ᕱ'
GS_SYM_BACKUP_REF='⟲'
GS_SYM_REBASE='ᚢ'
GS_SYM_MERGE='⑃'
GS_SYM_LOCAL_OK='✓'

# svn symbols
RS_SYM_SVN='svn'
RS_SYM_SVN_REPO_PATH='|'
RS_SYM_SVN_UNKNOWN_URL='?'
RS_SYM_SVN_REV='@'
RS_SYM_SVN_DIRTY='dirty'

# asynchronously fetch updates for all remotes (does not run if already running)
function gs_remote_update_async() {
    if [[ ! $(ps) =~ git\ remote\ update ]]; then
        nohup git remote update >/dev/null 2>&1 &
    fi
}

# join elements of an array
function gs_join() {
    local IFS="$1"
    shift
    echo "$*"
}

# parse the branch info from `git status --porcelain --branch`
function rs_parse_branch_line() {
    # TODO: simplifiy - this seems overcomplicated, maybe just use a regex?
    local IFS=''
    while read -r line; do
        local XY=${line:0:2}
        case "$XY" in
            \#\#)  echo "${line:3}"; break ;;
        esac
    done <<< "$1"
}

function rs_git_stash() {
    local git_stash_list=$(git stash list)
    if [ "$git_stash_list" ]; then
        local git_num_stashed=0
        # TODO: easier way to count number of lines in a string var?
        local IFS=''
        while read -r line; do
            ((git_num_stashed++))
        done <<< "$git_stash_list"
        echo "$(gs_color "$GS_COLOR_STASHED" "$git_num_stashed")$GS_SYM_STASHED"
    fi
}

function rs_git_backup_refs() {
    local git_show_ref=$(git show-ref)
    if [ "$git_show_ref" ]; then
        local git_num_orig_refs=0
        # TODO: easier way to do this?
        local IFS=''
        while read -r line; do
            if [[ "$line" =~ ^[0-9a-f]+[[:space:]]+refs/original ]]; then
                ((git_num_orig_refs++))
            fi
        done <<< "$git_show_ref"
        if [ "$git_num_orig_refs" -gt 0 ]; then
            echo "$(gs_color "$GS_COLOR_BACKUP_REF" "$git_num_orig_refs")$GS_SYM_BACKUP_REF"
        else
            echo ''
        fi
    fi
}

# arguments
# $1 - git base dir
function rs_git_rebase() {
    local git_dir="$1"
    local git_rebase_head=''
    if [ -d "$git_dir/rebase-apply" ] || [ -d "$git_dir/rebase-merge" ]; then
        if [ -f "$git_dir/rebase-apply/head-name" ]; then
            git_rebase_head="$(cat "$git_dir/rebase-apply/head-name")"
        elif [ -f "$git_dir/rebase-merge/head-name" ]; then
            git_rebase_head="$(cat "$git_dir/rebase-merge/head-name")"
        else
            git_rebase_head="!!"
        fi
        if [[ "$git_rebase_head" =~ .*/([^/]+) ]]; then
            git_rebase_head="${BASH_REMATCH[1]}"
        fi
        echo "$GS_SYM_REBASE$(gs_color "$GS_COLOR_REBASE" "$git_rebase_head")"
    fi
}

# arguments
# $1 - git base directory
function rs_git_merge() {
    local git_dir="$1"
    if [ -f "$git_dir/MERGE_HEAD" ]; then
        local git_merge_head="$(cat "$git_dir/MERGE_HEAD")"
        local git_merge_branch="$(git branch --no-color --contains "$git_merge_head")"
        local git_merge_name=''
        if [ "$git_merge_branch" ]; then
            # remove '*' and leading whitespace from branch name
            git_merge_name="${git_merge_branch/\*/ }"
            git_merge_name="${git_merge_name#"${git_merge_name%%[![:space:]]*}"}"
        else
            git_merge_name="${git_merge_head:0:8}"
        fi
        echo "$GS_SYM_MERGE$(gs_color "$GS_COLOR_MERGE" "$git_merge_name")"
    fi
}

# combine local status into a string
# arguments:
# $1 - git base directory
function rs_git_local_status() {
    local git_dir="$1"
    local git_num_staged=0
    local git_num_modified=0
    local git_num_conflict=0
    local git_num_untracked=0
    local IFS=''
    while read -r line; do
        XY=${line:0:2}
        case "$XY" in
            U?)     ((git_num_conflict++)) ;;  # unmerged
            ?U)     ((git_num_conflict++)) ;;  # unmerged
            DD)     ((git_num_conflict++)) ;;  # unmerged (both deleted)
            AA)     ((git_num_conflict++)) ;;  # unmerged (both added)
            ?[MDT]) ((git_num_modified++)) ;;  # modified/deleted/typechange in working tree
            \?\?)   ((git_num_untracked++)) ;; # untracked in index and working tree
        esac
        case "$XY" in
            [MARCD]?) ((git_num_staged++)) ;; # modified/added/renamed/copied/deleted in index
        esac
    done <<< "$git_status_porcelain"

    if [ "$git_num_staged" -gt 0 ]; then
        local git_staged="$(gs_color "$GS_COLOR_STAGED" "$git_num_staged")$GS_SYM_STAGED"
    fi
    if [ "$git_num_modified" -gt 0 ]; then
        local git_modified="$(gs_color "$GS_COLOR_MODIFIED" "$git_num_modified")$GS_SYM_MODIFIED"
    fi
    if [ "$git_num_untracked" -gt 0 ]; then
        local git_untracked="$(gs_color "$GS_COLOR_UNTRACKED" "$git_num_untracked")$GS_SYM_UNTRACKED"
    fi
    if [ "$git_num_conflict" -gt 0 ]; then
        local git_conflict="$(gs_color "$GS_COLOR_CONFLICT" "$git_num_conflict")$GS_SYM_CONFLICT"
    fi

    local git_stashed=$(rs_git_stash)
    local git_backup_refs=$(rs_git_backup_refs)
    local git_rebase=$(rs_git_rebase "$git_dir")
    local git_merge=$(rs_git_merge "$git_dir")

    local git_stat_arr=($git_rebase $git_merge $git_conflict $git_backup_refs $git_staged $git_modified $git_stashed $git_untracked)
    local git_local_status=$(gs_join ' ' "${git_stat_arr[@]}")
    if [[ ! -z "${git_local_status// }" ]]; then
        echo "$git_local_status"
    else
        echo "$(gs_color "$GS_COLOR_LOCAL_OK" "$GS_SYM_LOCAL_OK")"
    fi
}

# arguments:
# $1 - git granch line from `git status --porcelain --branch`, without the leading "## "
function gs_set_remote_status() {
    # figure out local and remote branch, and ahead/behind/diverged
    if [[ "$1" =~ Initial\ commit\ on\ (.+) ]]; then
        # "Initial commit on master"
        gs_head="$GS_SYM_BRANCH$(gs_color "$GS_COLOR_BRANCH" "${BASH_REMATCH[1]}")"
        git_remote_status=$(gs_color "$GS_COLOR_NO_REMOTE" "$GS_SYM_NO_REMOTE")
    elif [[ "$1" =~ no\ branch ]]; then
        # "HEAD (no branch)"
        git_tag=$(git describe --exact-match 2>/dev/null)
        if [ -n "$git_tag" ]; then
            gs_head="$GS_SYM_TAG$(gs_color "$GS_COLOR_TAG" "$git_tag")"
            # to check if tag has been pushed, can do something like:
            # `git ls-remote --exit-code --tags origin v1.0 2>/dev/null`
            # but that's slow
        else
            git_commit_hash=$(git rev-parse --short HEAD)
            gs_head="$GS_SYM_HASH$(gs_color "$GS_COLOR_HASH" "$git_commit_hash")"
        fi
        git_remote_status=$(gs_color "$GS_COLOR_NO_REMOTE" "$GS_SYM_NO_REMOTE")
    else
        # "master...origin/master [ahead 8]"
        # "master...origin/master [behind 12]"
        # "master...origin/master [ahead 1, behind 7]"
        git_branch_arr=(${1//.../ })
        gs_head="$GS_SYM_BRANCH$(gs_color "$GS_COLOR_BRANCH" "${git_branch_arr[0]}")"
        git_branch_arr=("${git_branch_arr[@]:1}") # remove the branch from the array
        # remote tracking branch
        if [[ ${git_branch_arr[0]} ]]; then
            git_origin=${git_branch_arr[0]}
            git_upstream=${git_origin/origin/upstream}
            git_branch_arr=("${git_branch_arr[@]:1}") # remove the remote branch from the array
            git_ahead_behind="${git_branch_arr[*]}" # combine array elements
            if [[ "$git_ahead_behind" =~ ahead\ ([0-9]+) ]]; then
                git_ahead="$(gs_color "$GS_COLOR_NEED_PUSH" "${BASH_REMATCH[1]}")$GS_SYM_NEED_PUSH"
            fi
            if [[ "$git_ahead_behind" =~ behind\ ([0-9]+) ]]; then
                git_behind="$(gs_color "$GS_COLOR_NEED_PULL" "${BASH_REMATCH[1]}")$GS_SYM_NEED_PULL"
            fi
            git_rev_list=$(git rev-list --count --left-right ${git_origin}..${git_upstream} 2>/dev/null)
            if [ "$?" -eq 0 ]; then
                git_fork_arr=($git_rev_list) # will split into array because it's 2 numbers separated by spaces
                if [ "${git_fork_arr[0]}" -gt 0 ]; then
                    git_fork_ahead=$(gs_color "$GS_COLOR_FORK_AHEAD" "${git_fork_arr[0]}")
                fi
                if [ "${git_fork_arr[1]}" -gt 0 ]; then
                    git_fork_behind=$(gs_color "$GS_COLOR_FORK_BEHIND" "${git_fork_arr[1]}")
                fi
                if [ "$git_fork_ahead" ] || [ "$git_fork_behind" ]; then
                    git_fork_status="${git_fork_ahead}$GS_SYM_FORK${git_fork_behind}"
                fi
            fi
            if [ "$git_behind" ] || [ "$git_ahead" ] || [ "$git_fork_status" ]; then
                git_remote_stat_arr=($git_behind $git_ahead $git_fork_status)
                git_remote_status=$(gs_join ' ' "${git_remote_stat_arr[@]}")
            else
                # all sync-ed up
                git_remote_status=$(gs_color "$GS_COLOR_REMOTE_OK" "$GS_SYM_REMOTE_OK")
            fi
        else
            # local branch with no remote tracking
            git_remote_branches=$(git branch -r)
            if [ "$git_remote_branches" ]; then
                git_remotes_arr=($git_remote_branches)
                git_excludes_arr=()
                for r in "${git_remotes_arr[@]}"; do
                    if [[ "$r" != "->" ]]; then
                        git_excludes_arr+=("^$r")
                    fi
                done
                git_excludes=$(gs_join ' ' "${git_excludes_arr[@]}")
            fi
            # figure out how many commits exist on this branch that are not in the remotes
            git_local_commits=$(git rev-list --count HEAD ${git_excludes} 2>/dev/null)
            if [ "$?" -eq 0 ] && [ "$git_local_commits" -gt 0 ]; then
                git_remote_status="$(gs_color "$GS_COLOR_NEED_PUSH_UNTRACKED" "$git_local_commits")$GS_SYM_NEED_PUSH_UNTRACKED"
            else
                git_remote_status=$(gs_color "$GS_COLOR_NO_REMOTE" "$GS_SYM_NO_REMOTE")
            fi

        fi
    fi
}

# show info about what kind of repo we're in
# some code and ideas from:
# - http://zanshin.net/2012/03/09/wordy-nerdy-zsh-prompt/
# - https://github.com/sjl/oh-my-zsh/commit/3d22ee248c6bce357c018a93d31f8d292d2cb4cd
# - https://github.com/magicmonty/bash-git-prompt
function repo_status() {
    rs_status=''
    # git
    git_status_porcelain=$(git status --porcelain --untracked-files=all --branch 2>/dev/null)
    if [ "$?" -eq 0 ]; then
        local gs_git=$(gs_color "$GS_COLOR_GIT" "$GS_SYM_GIT")
        local git_dir=$(git rev-parse --git-dir)
        local git_branch_info=$(rs_parse_branch_line "$git_status_porcelain")
        gs_remote_update_async
        gs_set_remote_status "$git_branch_info"
        local git_local_status=$(rs_git_local_status "$git_dir")
        rs_status+="  $gs_git$gs_head $git_remote_status / $git_local_status"
    fi
    # svn
    rs_svn_info=$(svn info 2>/dev/null)
    if [ "$?" -eq 0 ]; then
        rs_svn=$(gs_color "$RS_COLOR_SVN" "$RS_SYM_SVN")
        # TODO: split URI and path with something like '/'
        if [[ "$rs_svn_info" =~ URL:\ ([^$'\n']+) ]]; then
            svn_url="${BASH_REMATCH[1]}"
            svn_protocol=$(expr "$svn_url" : '\([a-z]\+://\)') # match the svn:// or https:// from the start of the repo
            svn_path="$RS_SYM_SVN_REPO_PATH$(gs_color "$RS_COLOR_SVN_PATH" "${svn_url#$svn_protocol}")"
        else
            svn_path=$(gs_color "$RS_COLOR_SVN_PATH" "$RS_SYM_SVN_UNKNOWN_URL")
        fi
        if [[ "$rs_svn_info" =~ Revision:\ ([0-9]+) ]]; then
            svn_revision="$RS_SYM_SVN_REV$(gs_color "$RS_COLOR_SVN_REV" "${BASH_REMATCH[1]}")"
        fi
        svn_status=$(svn status 2>/dev/null)
        # TODO - more detailed status (see `svn status --help` for the codes)
        if [[ "$svn_status" =~ [?!AM]([[:space:]]+[^$'\n']+) ]]; then
            svn_dirty=$(gs_color "$RS_COLOR_SVN_DIRTY" "$RS_SYM_SVN_DIRTY")
        else
            svn_dirty=$(gs_color "$RS_COLOR_SVN_OK" "✓")
        fi
        rs_status+="  $rs_svn$svn_path$svn_revision $svn_dirty"
    fi
    echo -e "$rs_status"
}

