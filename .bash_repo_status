#!/usr/bin/env bash

# colors used in the prompt
COLOR_LIGHT_GRAY='\033[1;30m'
COLOR_RED='\033[0;31m'
COLOR_GREEN='\033[0;32m'
COLOR_LIGHT_BLUE='\033[1;34m'
COLOR_LIGHT_MAGENTA='\033[1;35m'
COLOR_ORANGE='\033[38;5;95;38;5;208m'
COLOR_RESET='\033[0m'

# git colors
GS_COLOR_GIT="$COLOR_LIGHT_BLUE"
GS_COLOR_BRANCH="$COLOR_LIGHT_BLUE"
GS_COLOR_REVIEWID="$COLOR_LIGHT_BLUE"
GS_COLOR_NO_REMOTE="$COLOR_LIGHT_BLUE"
GS_COLOR_TAG="$COLOR_LIGHT_BLUE"
GS_COLOR_HASH="$COLOR_LIGHT_BLUE"
GS_COLOR_NEED_PUSH="$COLOR_LIGHT_BLUE"
GS_COLOR_NEED_PULL="$COLOR_LIGHT_BLUE"
GS_COLOR_FORK_AHEAD="$COLOR_LIGHT_BLUE"
GS_COLOR_FORK_BEHIND="$COLOR_LIGHT_BLUE"
GS_COLOR_REMOTE_OK="$COLOR_LIGHT_BLUE"
GS_COLOR_NEED_PUSH_UNTRACKED="$COLOR_LIGHT_BLUE"
GS_COLOR_CONFLICT="$COLOR_RED"
GS_COLOR_REBASE="$COLOR_RED"
GS_COLOR_MERGE="$COLOR_RED"
GS_COLOR_BISECT="$COLOR_RED"
GS_COLOR_STAGED="$COLOR_GREEN"
GS_COLOR_LOCAL_OK="$COLOR_GREEN"
GS_COLOR_UNTRACKED="$COLOR_LIGHT_GRAY"
GS_COLOR_STASHED="$COLOR_LIGHT_MAGENTA"
GS_COLOR_BACKUP_REF="$COLOR_ORANGE"
GS_COLOR_MODIFIED="$COLOR_ORANGE"

# svn colors
RS_COLOR_SVN="$COLOR_LIGHT_BLUE"
RS_COLOR_SVN_PATH="$COLOR_LIGHT_BLUE"
RS_COLOR_SVN_REV="$COLOR_LIGHT_BLUE"
RS_COLOR_SVN_OK="$COLOR_GREEN"
RS_COLOR_SVN_ERROR="$COLOR_RED"
# TODO
RS_COLOR_SVN_CONFLICTED="$COLOR_RED"
RS_COLOR_SVN_ADDED="$COLOR_RED"
RS_COLOR_SVN_MODIFIED="$COLOR_RED"
RS_COLOR_SVN_DELETED="$COLOR_RED"
RS_COLOR_SVN_LOCKED="$COLOR_RED"
RS_COLOR_SVN_ADD_HISTORY="$COLOR_RED"
RS_COLOR_SVN_UNTRACKED="$COLOR_RED"
RS_COLOR_SVN_EXTERNAL="$COLOR_RED"
RS_COLOR_SVN_SWITCHED="$COLOR_RED"
RS_COLOR_SVN_IGNORED="$COLOR_RED"
RS_COLOR_SVN_MISSING="$COLOR_RED"
RS_COLOR_SVN_OBSTRUCTED="$COLOR_RED"

# git symbols
GS_SYM_GIT='git'
GS_SYM_BRANCH='|'
GS_SYM_TAG='»'
GS_SYM_HASH='#'
GS_SYM_REVIEWBOARD='r'
GS_SYM_NO_REMOTE='-'
GS_SYM_NEED_PUSH='⇧'
GS_SYM_NEED_PULL='⇩'
GS_SYM_NEED_PUSH_UNTRACKED='⇪'
#GS_SYM_FORK='⑂'
GS_SYM_FORK='Ⴤ'
GS_SYM_REMOTE_OK='✓'
GS_SYM_STAGED='+'
GS_SYM_MODIFIED='*'
GS_SYM_UNTRACKED='?'
GS_SYM_CONFLICT='!'
GS_SYM_STASHED='ᕱ'
GS_SYM_BACKUP_REF='⟲'
GS_SYM_REBASE='ᚢ'
GS_SYM_MERGE='⑃'
GS_SYM_BISECT='⟀'
GS_SYM_LOCAL_OK='✓'

# svn symbols
RS_SYM_SVN='svn'
RS_SYM_SVN_REPO_PATH='|'
RS_SYM_SVN_UNKNOWN_URL='?'
RS_SYM_SVN_REV='@'
RS_SYM_SVN_ERROR='!'
# TODO
RS_SYM_SVN_CONFLICTED="<conflicted>" #!
RS_SYM_SVN_ADDED="<added>" #+
RS_SYM_SVN_MODIFIED="<modified>" #*
RS_SYM_SVN_DELETED="<deleted>" #x
RS_SYM_SVN_LOCKED="<locked>" #lck
RS_SYM_SVN_ADD_HISTORY="<add-history>" # +h
RS_SYM_SVN_UNTRACKED="<untracked>" #?
RS_SYM_SVN_EXTERNAL="<external>" #ext
RS_SYM_SVN_SWITCHED="<switched>" #sw
RS_SYM_SVN_IGNORED="<ignored>" #i
RS_SYM_SVN_MISSING="<missing>" #mis
RS_SYM_SVN_OBSTRUCTED="<obstructed>" #obs

# function to set colors
# argument(s)
# $1 - variable to write
# $2 - color esc sequence
# $3 - string to color
# function gs_color()  { echo "$1$2$COLOR_RESET"; }
function gs_color()  { printf -v "$1" "$2$3$COLOR_RESET"; }

# asynchronously fetch updates for all remotes (does not run if already running)
function gs_remote_update_async() {
    if [[ ! $(ps) =~ git\ remote\ update ]]; then
        nohup git remote update >/dev/null 2>&1 &
    fi
}

# join elements of an array with " " (space) character
# arguments:
# $1 - return variable name
# $2 - array elements to join
function gs_join_by_space() {
    local varname="$1"
    local first_element="$2"
    shift 2 || shift $(($#)) # account for case of empty array (thanks http://stackoverflow.com/a/23673883)
    printf -v "$varname" "%s" "$first_element${@/#/ }"
}

# arguments:
# $1 - return variable name
# $2 - counter
# $3 - color
# $4 - trailing symbol
# TODO - not thread safe if I parallelize this stuff
function rs_format_count() {
    if [ "$2" -gt 0 ]; then
        unset -v colored_string
        gs_color colored_string "$3" "$2"
        printf -v "$1" "$colored_string$4"
    fi
}

# parse the branch info from `git status --porcelain --branch`
# arguments:
# $1 - return variable name
# $2 - output lines from `git status ...`
function rs_parse_branch_line() {
    # TODO: simplifiy - this seems overcomplicated, maybe just use a regex?
    local IFS=''
    while read -r line; do
        local XY=${line:0:2}
        case "$XY" in
            \#\#)  printf -v "$1" "${line:3}"; break ;;
        esac
    done <<< "$2"
}

# parse the output from `git stash list`
# arguments:
# $1 - return variable name
function rs_git_stash() {
    local git_stash_list=$(git stash list)
    if [ "$git_stash_list" ]; then
        local git_num_stashed=0
        # TODO: easier way to count number of lines in a string var?
        local IFS=''
        while read -r line; do
            ((git_num_stashed++))
        done <<< "$git_stash_list"
        unset -v colored_stash_string
        gs_color colored_stash_string "$GS_COLOR_STASHED" "$git_num_stashed"
        printf -v "$1" "$colored_stash_string$GS_SYM_STASHED"
    fi
}

# parse the output from `git show-ref original`
# argument(s):
# $1 - return variable name
function rs_git_backup_refs() {
    local git_show_ref=$(git show-ref original)
    if [ "$git_show_ref" ]; then
        local git_num_orig_refs=0
        # TODO: easier way to do this?
        local IFS=''
        while read -r line; do
            if [[ "$line" =~ ^[0-9a-f]+[[:space:]]+refs/original ]]; then
                ((git_num_orig_refs++))
            fi
        done <<< "$git_show_ref"
        rs_format_count "$1" "$git_num_orig_refs" "$GS_COLOR_BACKUP_REF" "$GS_SYM_BACKUP_REF"
    fi
}

# figure out if there is a rebase happening
# arguments
# $1 - return variable name
# $2 - git base dir
function rs_git_rebase() {
    local git_dir="$2"
    local git_rebase_head=''
    if [ -d "$git_dir/rebase-apply" ] || [ -d "$git_dir/rebase-merge" ]; then
        if [ -f "$git_dir/rebase-apply/head-name" ]; then
            git_rebase_head="$(<"$git_dir/rebase-apply/head-name")"
        elif [ -f "$git_dir/rebase-merge/head-name" ]; then
            git_rebase_head="$(<"$git_dir/rebase-merge/head-name")"
        else
            git_rebase_head="!!"
        fi
        if [[ "$git_rebase_head" =~ .*/([^/]+) ]]; then
            git_rebase_head="${BASH_REMATCH[1]}"
        fi
        unset -v colored_rebase_string
        gs_color colored_rebase_string "$GS_COLOR_REBASE" "$git_rebase_head"
        printf -v "$1" "$GS_SYM_REBASE$colored_rebase_string"
    fi
}

# figure out if there is a merge happening
# arguments
# $1 - return variable name
# $2 - git base directory
function rs_git_merge() {
    local git_dir="$2"
    if [ -f "$git_dir/MERGE_HEAD" ]; then
        local git_merge_head="$(<"$git_dir/MERGE_HEAD")"
        local git_merge_branch="$(git branch --no-color --contains "$git_merge_head")"
        local git_merge_name=''
        if [ "$git_merge_branch" ]; then
            # remove '*' and leading whitespace from branch name
            git_merge_name="${git_merge_branch/\*/ }"
            git_merge_name="${git_merge_name#"${git_merge_name%%[![:space:]]*}"}"
        else
            git_merge_name="${git_merge_head:0:8}"
        fi
        unset -v colored_merge_string
        gs_color colored_merge_string "$GS_COLOR_MERGE" "$git_merge_name"
        printf -v "$1" "$GS_SYM_MERGE$colored_merge_string"
    fi
}

# figure out if there is a bisect happening
# arguments
# $1 - return variable name
# $2 - git base directory
function rs_git_bisect() {
    unset -v "$1"
    local git_dir="$2"
    if [ -f "$git_dir/BISECT_START" ]; then
        local git_bisect_start="$(<"$git_dir/BISECT_START")"
        unset -v colored_bisect_string
        gs_color colored_bisect_string "$GS_COLOR_BISECT" "$git_bisect_start"
        printf -v "$1" "$GS_SYM_BISECT$colored_bisect_string"
    fi
}

# combine local status into a string
# arguments:
# $1 - return variable name
# $2 - git base directory
# $3 - git granch line from `git status --porcelain --branch`, without the leading "## "
function rs_git_local_status() {
    local git_dir="$2"
    local git_num_staged=0
    local git_num_modified=0
    local git_num_conflict=0
    local git_num_untracked=0
    local IFS=''
    while read -r line; do
        XY=${line:0:2}
        case "$XY" in
            U?)     ((git_num_conflict++)) ;;  # unmerged
            ?U)     ((git_num_conflict++)) ;;  # unmerged
            DD)     ((git_num_conflict++)) ;;  # unmerged (both deleted)
            AA)     ((git_num_conflict++)) ;;  # unmerged (both added)
            ?[MDT]) ((git_num_modified++)) ;;  # modified/deleted/typechange in working tree
            \?\?)   ((git_num_untracked++)) ;; # untracked in index and working tree
        esac
        case "$XY" in
            [MARCD]?) ((git_num_staged++)) ;; # modified/added/renamed/copied/deleted in index
        esac
    done <<< "$3"

    rs_format_count git_staged "$git_num_staged" "$GS_COLOR_STAGED" "$GS_SYM_STAGED"
    rs_format_count git_modified "$git_num_modified" "$GS_COLOR_MODIFIED" "$GS_SYM_MODIFIED"
    rs_format_count git_untracked "$git_num_untracked" "$GS_COLOR_UNTRACKED" "$GS_SYM_UNTRACKED"
    rs_format_count git_conflict "$git_num_conflict" "$GS_COLOR_CONFLICT" "$GS_SYM_CONFLICT"

    rs_git_stash git_stashed
    rs_git_backup_refs git_backup_refs
    rs_git_rebase git_rebase "$git_dir"
    rs_git_merge git_merge "$git_dir"
    rs_git_bisect git_bisect "$git_dir"

    local git_stat_arr=($git_rebase $git_merge $git_bisect $git_conflict $git_backup_refs $git_staged $git_modified $git_stashed $git_untracked)
    gs_join_by_space git_local_status "${git_stat_arr[@]}"
    if [[ ! -z "${git_local_status// }" ]]; then
        printf -v "$1" "$git_local_status"
    else
        gs_color "$1" "$GS_COLOR_LOCAL_OK" "$GS_SYM_LOCAL_OK"
    fi
}

# return local branch/tag/commit and remote branch if it exists
# arguments:
# $1 - return variable name for head
# $2 - return variable name for head (nocolor)
# $3 - return variable name for origin
# $4 - git branch line from `git status --porcelain --branch`, without the leading "## "
function rs_git_head_origin() {
    unset -v "$1" "$2" "$3"
    local status_line="$4"
    if [[ "$status_line" =~ Initial\ commit\ on\ (.+) ]]; then
        # "Initial commit on master" - local branch only
        # "Initial commit on master...origin/master" - checked out empty repo
        unset -v colored_head_string
        gs_color colored_head_string "$GS_COLOR_BRANCH" "${BASH_REMATCH[1]%%...*}"
        printf -v "$1" "$GS_SYM_BRANCH$colored_head_string"
        printf -v "$2" "${BASH_REMATCH[1]%%...*}"
    elif [[ "$status_line" =~ no\ branch ]]; then
        # "HEAD (no branch)" - on tag or detached on commit
        local git_tag=$(git describe --exact-match 2>/dev/null)
        if [ -n "$git_tag" ]; then
            unset -v colored_tag_string
            gs_color colored_tag_string "$GS_COLOR_TAG" "$git_tag"
            printf -v "$1" "$GS_SYM_TAG$colored_tag_string"
        else
            local git_commit_hash=$(git rev-parse --short HEAD)
            unset -v colored_hash_string
            gs_color colored_hash_string "$GS_COLOR_HASH" "$git_commit_hash"
            printf -v "$1" "$GS_SYM_HASH$colored_hash_string"
        fi
    else
        # "master"
        # "master...origin/master [gone]"
        # "master...origin/master [ahead 8]"
        # "master...origin/master [behind 12]"
        # "master...origin/master [ahead 1, behind 7]"
        local git_branch_arr=( ${status_line//.../ } )
        unset -v colored_branches_string
        gs_color colored_branches_string "$GS_COLOR_BRANCH" "${git_branch_arr[0]}"
        printf -v "$1" "$GS_SYM_BRANCH$colored_branches_string"
        printf -v "$2" "${git_branch_arr[0]}"
        printf -v "$3" "${git_branch_arr[1]}"
    fi
}

# arguments:
# $1 - return variable name
# $2 - local git branch
function rs_git_reviewid() {
    unset -v "$1"
    local git_reviewboard_id=$(git config --get branch.$2.reviewid)
    if [ -n "$git_reviewboard_id" ]; then
        unset -v colored_review_string
        gs_color colored_review_string "$GS_COLOR_REVIEWID" "$git_reviewboard_id"
        printf -v "$1" " $GS_SYM_REVIEWBOARD$colored_review_string"
    fi
}

# arguments:
# $1 - return variable name
# $2 - local git branch
# $3 - origin branch that is tracking the local branch (if it exists)
function rs_git_remote_status() {
    unset -v "$1"
    local git_head="$2"
    local git_origin="$3"
    local git_upstream="${3/origin/upstream}"
    if [[ -z "$git_origin" ]]; then
        # local branch with no remote tracking
        local git_excludes=''
        local git_remote_branches=$(git branch -r)
        if [ -n "$git_remote_branches" ]; then
            local git_remotes_arr=($git_remote_branches)
            local git_excludes_arr=()
            for r in "${git_remotes_arr[@]}"; do
                if [[ "$r" != "->" ]]; then
                    git_excludes_arr+=("^$r")
                fi
            done
            gs_join_by_space git_excludes "${git_excludes_arr[@]}"
        fi
        # figure out how many commits exist on this branch that are not in the remotes
        local git_local_commits=$(git rev-list --count HEAD ${git_excludes} 2>/dev/null)
        if [ -n "$git_local_commits" ] && [ "$git_local_commits" -gt 0 ]; then
            unset -v colored_string
            gs_color colored_string "$GS_COLOR_NEED_PUSH_UNTRACKED" "$git_local_commits"
            git_remote_status="$colored_string$GS_SYM_NEED_PUSH_UNTRACKED"
        else
            unset -v git_remote_status
            gs_color git_remote_status "$GS_COLOR_NO_REMOTE" "$GS_SYM_NO_REMOTE"
        fi
        printf -v "$1" "$git_remote_status"
    else
        # remote tracking branch
        local git_rev_list_origin=$(git rev-list --count --left-right ${git_head}...${git_origin} 2>/dev/null)
        if [ "$?" -eq 0 ] && [ -n "$git_rev_list_origin" ]; then
            local git_origin_arr=($git_rev_list_origin) # will split into array because it's 2 numbers separated by spaces
            # local git_ahead=$(rs_format_count "${git_origin_arr[0]}" "$GS_COLOR_NEED_PUSH" "$GS_SYM_NEED_PUSH")
            # local git_behind=$(rs_format_count "${git_origin_arr[1]}" "$GS_COLOR_NEED_PULL" "$GS_SYM_NEED_PULL")
            rs_format_count git_ahead "${git_origin_arr[0]}" "$GS_COLOR_NEED_PUSH" "$GS_SYM_NEED_PUSH"
            rs_format_count git_behind "${git_origin_arr[1]}" "$GS_COLOR_NEED_PULL" "$GS_SYM_NEED_PULL"
        fi
        git_rev_list_upstream=$(git rev-list --count --left-right ${git_origin}...${git_upstream} 2>/dev/null)
        if [ "$?" -eq 0 ]; then
            local git_upstream_arr=($git_rev_list_upstream) # will split into array because it's 2 numbers separated by spaces
            # local git_fork_ahead=$(rs_format_count "${git_upstream_arr[0]}" "$GS_COLOR_FORK_AHEAD" "")
            # local git_fork_behind=$(rs_format_count "${git_upstream_arr[1]}" "$GS_COLOR_FORK_BEHIND" "")
            rs_format_count git_fork_ahead "${git_upstream_arr[0]}" "$GS_COLOR_FORK_AHEAD" ""
            rs_format_count git_fork_behind "${git_upstream_arr[1]}" "$GS_COLOR_FORK_BEHIND" ""
            if [ "$git_fork_ahead" ] || [ "$git_fork_behind" ]; then
                local git_fork_status="${git_fork_ahead}$GS_SYM_FORK${git_fork_behind}"
            fi
        fi

        if [ "$git_behind" ] || [ "$git_ahead" ] || [ "$git_fork_status" ]; then
            local git_remote_stat_arr=($git_behind $git_ahead $git_fork_status)
            gs_join_by_space git_remote_status "${git_remote_stat_arr[@]}"
        else
            # all sync-ed up
            unset -v git_remote_status
            gs_color git_remote_status "$GS_COLOR_REMOTE_OK" "$GS_SYM_REMOTE_OK"
        fi
        printf -v "$1" "$git_remote_status"
    fi
}

function rs_svn_local_status() {
    local svn_status=$(svn status 2>/dev/null)

    local svn_num_conflicted=0
    local svn_num_added=0
    local svn_num_modified=0
    local svn_num_deleted=0
    local svn_num_locked=0
    local svn_num_history=0
    local svn_num_untracked=0
    local svn_num_external=0
    local svn_num_switched=0
    local svn_num_ignored=0
    local svn_num_missing=0
    local svn_num_obstructed=0
    while IFS='' read -r line; do
        local svn_stat_columns=${line:0:7}
        case "$svn_stat_columns" in
            #  see `svn status --help` for details on these codes
            C??????)  ((svn_num_conflicted++)) ;; # item conflicted
            ?C?????)  ((svn_num_conflicted++)) ;; # file/directory properties conflicted
            ??????C)  ((svn_num_conflicted++)) ;; # tree conflict
            A??????)  ((svn_num_added++)) ;; # item added
            [MR]??????)  ((svn_num_modified++)) ;; # item modified/replaced
            ?M?????)  ((svn_num_modified++)) ;; # file/directory properties modified
            D??????)  ((svn_num_deleted++)) ;; # item deleted
            \???????)  ((svn_num_untracked++)) ;; # item untracked
            I??????)  ((svn_num_ignored++)) ;; # item ignored
            ??L????)  ((svn_num_locked++)) ;; # working copy directory locked
            ?????K?)  ((svn_num_locked++)) ;; # repository lock token present
            ???+???)  ((svn_num_history++)) ;; # commit will contain addition-with-history
            X??????)  ((svn_num_external++)) ;; # unversioned directory created by externals
            ????X??)  ((svn_num_external++)) ;; # versioned file created by externals
            ????S??)  ((svn_num_switched++)) ;; # item has a switched URL
            \!??????)  ((svn_num_missing++)) ;; # item missing (removed by non-svn command)
            ~??????)  ((svn_num_obstructed++)) ;; # item obstructed by some item of a different kind
        esac
    done <<< "$svn_status"

    local svn_conflicted=$(rs_format_count "$svn_num_conflicted" "$RS_COLOR_SVN_CONFLICTED" "$RS_SYM_SVN_CONFLICTED")
    local svn_added=$(rs_format_count "$svn_num_added" "$RS_COLOR_SVN_ADDED" "$RS_SYM_SVN_ADDED")
    local svn_modified=$(rs_format_count "$svn_num_modified" "$RS_COLOR_SVN_MODIFIED" "$RS_SYM_SVN_MODIFIED")
    local svn_deleted=$(rs_format_count "$svn_num_deleted" "$RS_COLOR_SVN_DELETED" "$RS_SYM_SVN_DELETED")
    local svn_locked=$(rs_format_count "$svn_num_locked" "$RS_COLOR_SVN_LOCKED" "$RS_SYM_SVN_LOCKED")
    local svn_history=$(rs_format_count "$svn_num_history" "$RS_COLOR_SVN_ADD_HISTORY" "$RS_SYM_SVN_ADD_HISTORY")
    local svn_untracked=$(rs_format_count "$svn_num_untracked" "$RS_COLOR_SVN_UNTRACKED" "$RS_SYM_SVN_UNTRACKED")
    local svn_external=$(rs_format_count "$svn_num_external" "$RS_COLOR_SVN_EXTERNAL" "$RS_SYM_SVN_EXTERNAL")
    local svn_switched=$(rs_format_count "$svn_num_switched" "$RS_COLOR_SVN_SWITCHED" "$RS_SYM_SVN_SWITCHED")
    local svn_ignored=$(rs_format_count "$svn_num_ignored" "$RS_COLOR_SVN_IGNORED" "$RS_SYM_SVN_IGNORED")
    local svn_missing=$(rs_format_count "$svn_num_missing" "$RS_COLOR_SVN_MISSING" "$RS_SYM_SVN_MISSING")
    local svn_obstructed=$(rs_format_count "$svn_num_obstructed" "$RS_COLOR_SVN_OBSTRUCTED" "$RS_SYM_SVN_OBSTRUCTED")

    local svn_stat_arr=($svn_conflicted $svn_added $svn_modified $svn_deleted $svn_locked $svn_history $svn_untracked $svn_external $svn_switched $svn_ignored $svn_missing $svn_obstructed)
    gs_join_by_space retval "${svn_stat_arr[@]}"
    echo "$retval"
}

# show info about what kind of repo we're in
# some code and ideas from:
# - http://zanshin.net/2012/03/09/wordy-nerdy-zsh-prompt/
# - https://github.com/sjl/oh-my-zsh/commit/3d22ee248c6bce357c018a93d31f8d292d2cb4cd
# - https://github.com/magicmonty/bash-git-prompt
function repo_status() {
    rs_status=''
    # git
    git_status_porcelain=$(git status --porcelain --untracked-files=normal --branch 2>/dev/null)
    if [ "$?" -eq 0 ]; then
        gs_remote_update_async
        unset -v gs_git
        gs_color gs_git "$GS_COLOR_GIT" "$GS_SYM_GIT"
        local git_dir=$(git rev-parse --git-dir)
        rs_parse_branch_line git_branch_info "$git_status_porcelain"
        rs_git_head_origin git_head git_head_nocolor git_origin "$git_branch_info"
        rs_git_reviewid git_reviewid "$git_head_nocolor"
        rs_git_remote_status git_remote_status "$git_head_nocolor" "$git_origin"
        rs_git_local_status git_local_status "$git_dir" "$git_status_porcelain"
        rs_status+="  $gs_git$git_head$git_reviewid $git_remote_status / $git_local_status"
    fi
    # svn
    # rs_svn=$(gs_color "$RS_COLOR_SVN" "$RS_SYM_SVN")
    # rs_svn_info=$(svn info 2>&1)
    # if [ "$?" -eq 0 ]; then
    #     # TODO: split URI and path with something like '/'
    #     if [[ "$rs_svn_info" =~ URL:\ ([^$'\n']+) ]]; then
    #         svn_url="${BASH_REMATCH[1]}"
    #         svn_protocol=$(expr "$svn_url" : '\([a-z]\+://\)') # match the svn:// or https:// from the start of the repo
    #         svn_path="$RS_SYM_SVN_REPO_PATH$(gs_color "$RS_COLOR_SVN_PATH" "${svn_url#$svn_protocol}")"
    #     else
    #         svn_path=$(gs_color "$RS_COLOR_SVN_PATH" "$RS_SYM_SVN_UNKNOWN_URL")
    #     fi
    #     if [[ "$rs_svn_info" =~ Revision:\ ([0-9]+) ]]; then
    #         svn_revision="$RS_SYM_SVN_REV$(gs_color "$RS_COLOR_SVN_REV" "${BASH_REMATCH[1]}")"
    #     fi

    #     local svn_local_status=$(rs_svn_local_status)

    #     rs_status+="  $rs_svn$svn_path$svn_revision $svn_local_status"
    # elif [ "$?" -eq 1 ]; then
    #     # TODO: break these into an error function
    #     if [[ "$rs_svn_info" =~ svn:\ E155021 ]]; then
    #         if [[ "$rs_svn_info" =~ \(format\ ([0-9]+)\) ]]; then
    #             svn_repo_format="${BASH_REMATCH[1]}"
    #         else
    #             svn_repo_format="?"
    #         fi
    #         svn_version=$(svn --version --quiet)
    #         svn_error="$RS_SYM_SVN_ERROR$(gs_color "$RS_COLOR_SVN_ERROR" " client too old (client: $svn_version, repo format: $svn_repo_format)")"
    #         rs_status+="  $rs_svn$svn_error"
    #     elif [[ "$rs_svn_info" =~ svn:\ E155036 ]]; then
    #         if [[ "$rs_svn_info" =~ \(format\ ([0-9]+) ]]; then
    #             svn_repo_format="${BASH_REMATCH[1]}"
    #         else
    #             svn_repo_format="?"
    #         fi
    #         svn_version=$(svn --version --quiet)
    #         svn_error="$RS_SYM_SVN_ERROR$(gs_color "$RS_COLOR_SVN_ERROR" " working copy too old (client: $svn_version, repo format: $svn_repo_format)")"
    #         rs_status+="  $rs_svn$svn_error"
    #     #elif [[ "$rs_svn_info" =~ svn:\ (E[0-9]+) ]]; then
    #     #    svn_error_code="${BASH_REMATCH[1]}"
    #     #    svn_error="$RS_SYM_SVN_ERROR$(gs_color "$RS_COLOR_SVN_ERROR" " unknown svn error: $svn_error_code")"
    #     #    rs_status+="  $rs_svn$svn_error"
    #     fi
    # fi
    echo -e "$rs_status"
}

# trace the calls that are made to git
function debug_repo_status_call_trace() {
    ( set -x; repo_status 2>&1 | grep " git " )
}

