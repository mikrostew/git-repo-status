#!/usr/bin/env bash

# colors used in the prompt
COLOR_LIGHT_GRAY='\033[1;30m'
COLOR_RED='\033[0;31m'
COLOR_GREEN='\033[0;32m'
COLOR_LIGHT_BLUE='\033[1;34m'
COLOR_LIGHT_MAGENTA='\033[1;35m'
COLOR_ORANGE='\033[38;5;95;38;5;208m'
COLOR_RESET='\033[0m'

# git colors
GS_COLOR_GIT="$COLOR_LIGHT_BLUE"
GS_COLOR_BRANCH="$COLOR_LIGHT_BLUE"
GS_COLOR_REVIEWID="$COLOR_LIGHT_BLUE"
GS_COLOR_NO_REMOTE="$COLOR_LIGHT_BLUE"
GS_COLOR_TAG="$COLOR_LIGHT_BLUE"
GS_COLOR_HASH="$COLOR_LIGHT_BLUE"
GS_COLOR_NEED_PUSH="$COLOR_LIGHT_BLUE"
GS_COLOR_NEED_PULL="$COLOR_LIGHT_BLUE"
GS_COLOR_FORK_AHEAD="$COLOR_LIGHT_BLUE"
GS_COLOR_FORK_BEHIND="$COLOR_LIGHT_BLUE"
GS_COLOR_REMOTE_OK="$COLOR_LIGHT_BLUE"
GS_COLOR_NEED_PUSH_UNTRACKED="$COLOR_LIGHT_BLUE"
GS_COLOR_CONFLICT="$COLOR_RED"
GS_COLOR_REBASE="$COLOR_RED"
GS_COLOR_MERGE="$COLOR_RED"
GS_COLOR_BISECT="$COLOR_RED"
GS_COLOR_STAGED="$COLOR_GREEN"
GS_COLOR_LOCAL_OK="$COLOR_GREEN"
GS_COLOR_UNTRACKED="$COLOR_LIGHT_GRAY"
GS_COLOR_STASHED="$COLOR_LIGHT_MAGENTA"
GS_COLOR_BACKUP_REF="$COLOR_ORANGE"
GS_COLOR_MODIFIED="$COLOR_ORANGE"

# svn colors
RS_COLOR_SVN="$COLOR_LIGHT_BLUE"
RS_COLOR_SVN_PATH="$COLOR_LIGHT_BLUE"
RS_COLOR_SVN_REV="$COLOR_LIGHT_BLUE"
RS_COLOR_SVN_OK="$COLOR_GREEN"
RS_COLOR_SVN_ERROR="$COLOR_RED"
# TODO
RS_COLOR_SVN_CONFLICTED="$COLOR_RED"
RS_COLOR_SVN_ADDED="$COLOR_RED"
RS_COLOR_SVN_MODIFIED="$COLOR_RED"
RS_COLOR_SVN_DELETED="$COLOR_RED"
RS_COLOR_SVN_LOCKED="$COLOR_RED"
RS_COLOR_SVN_ADD_HISTORY="$COLOR_RED"
RS_COLOR_SVN_UNTRACKED="$COLOR_RED"
RS_COLOR_SVN_EXTERNAL="$COLOR_RED"
RS_COLOR_SVN_SWITCHED="$COLOR_RED"
RS_COLOR_SVN_IGNORED="$COLOR_RED"
RS_COLOR_SVN_MISSING="$COLOR_RED"
RS_COLOR_SVN_OBSTRUCTED="$COLOR_RED"

# functions to set colors
function gs_color()  { echo "$1$2$COLOR_RESET"; }

# git symbols
GS_SYM_GIT='git'
GS_SYM_BRANCH='|'
GS_SYM_TAG='»'
GS_SYM_HASH='#'
GS_SYM_NO_REMOTE='-'
GS_SYM_NEED_PUSH='⇧'
GS_SYM_NEED_PULL='⇩'
GS_SYM_NEED_PUSH_UNTRACKED='⇪'
#GS_SYM_FORK='⑂'
GS_SYM_FORK='Ⴤ'
GS_SYM_REMOTE_OK='✓'
GS_SYM_STAGED='+'
GS_SYM_MODIFIED='*'
GS_SYM_UNTRACKED='?'
GS_SYM_CONFLICT='!'
GS_SYM_STASHED='ᕱ'
GS_SYM_BACKUP_REF='⟲'
GS_SYM_REBASE='ᚢ'
GS_SYM_MERGE='⑃'
GS_SYM_BISECT='⟀'
GS_SYM_LOCAL_OK='✓'

# svn symbols
RS_SYM_SVN='svn'
RS_SYM_SVN_REPO_PATH='|'
RS_SYM_SVN_UNKNOWN_URL='?'
RS_SYM_SVN_REV='@'
RS_SYM_SVN_ERROR='!'
# TODO
RS_SYM_SVN_CONFLICTED="<conflicted>" #!
RS_SYM_SVN_ADDED="<added>" #+
RS_SYM_SVN_MODIFIED="<modified>" #*
RS_SYM_SVN_DELETED="<deleted>" #x
RS_SYM_SVN_LOCKED="<locked>" #lck
RS_SYM_SVN_ADD_HISTORY="<add-history>" # +h
RS_SYM_SVN_UNTRACKED="<untracked>" #?
RS_SYM_SVN_EXTERNAL="<external>" #ext
RS_SYM_SVN_SWITCHED="<switched>" #sw
RS_SYM_SVN_IGNORED="<ignored>" #i
RS_SYM_SVN_MISSING="<missing>" #mis
RS_SYM_SVN_OBSTRUCTED="<obstructed>" #obs

# asynchronously fetch updates for all remotes (does not run if already running)
function gs_remote_update_async() {
    if [[ ! $(ps) =~ git\ remote\ update ]]; then
        nohup git remote update >/dev/null 2>&1 &
    fi
}

# join elements of an array
function gs_join() {
    local IFS="$1"
    shift
    echo "$*"
}

# arguments:
# $1 - counter
# $2 - color
# $3 - trailing symbol
function rs_format_count() {
    if [ "$1" -gt 0 ]; then
        echo "$(gs_color "$2" "$1")$3"
    fi
}

# parse the branch info from `git status --porcelain --branch`
function rs_parse_branch_line() {
    # TODO: simplifiy - this seems overcomplicated, maybe just use a regex?
    local IFS=''
    while read -r line; do
        local XY=${line:0:2}
        case "$XY" in
            \#\#)  echo "${line:3}"; break ;;
        esac
    done <<< "$1"
}

function rs_git_stash() {
    local git_stash_list=$(git stash list)
    if [ "$git_stash_list" ]; then
        local git_num_stashed=0
        # TODO: easier way to count number of lines in a string var?
        local IFS=''
        while read -r line; do
            ((git_num_stashed++))
        done <<< "$git_stash_list"
        echo "$(gs_color "$GS_COLOR_STASHED" "$git_num_stashed")$GS_SYM_STASHED"
    fi
}

function rs_git_backup_refs() {
    local git_show_ref=$(git show-ref original)
    if [ "$git_show_ref" ]; then
        local git_num_orig_refs=0
        # TODO: easier way to do this?
        local IFS=''
        while read -r line; do
            if [[ "$line" =~ ^[0-9a-f]+[[:space:]]+refs/original ]]; then
                ((git_num_orig_refs++))
            fi
        done <<< "$git_show_ref"
        echo $(rs_format_count "$git_num_orig_refs" "$GS_COLOR_BACKUP_REF" "$GS_SYM_BACKUP_REF")
    fi
}

# arguments
# $1 - git base dir
function rs_git_rebase() {
    local git_dir="$1"
    local git_rebase_head=''
    if [ -d "$git_dir/rebase-apply" ] || [ -d "$git_dir/rebase-merge" ]; then
        if [ -f "$git_dir/rebase-apply/head-name" ]; then
            git_rebase_head="$(cat "$git_dir/rebase-apply/head-name")"
        elif [ -f "$git_dir/rebase-merge/head-name" ]; then
            git_rebase_head="$(cat "$git_dir/rebase-merge/head-name")"
        else
            git_rebase_head="!!"
        fi
        if [[ "$git_rebase_head" =~ .*/([^/]+) ]]; then
            git_rebase_head="${BASH_REMATCH[1]}"
        fi
        echo "$GS_SYM_REBASE$(gs_color "$GS_COLOR_REBASE" "$git_rebase_head")"
    fi
}

# arguments
# $1 - git base directory
function rs_git_merge() {
    local git_dir="$1"
    if [ -f "$git_dir/MERGE_HEAD" ]; then
        local git_merge_head="$(cat "$git_dir/MERGE_HEAD")"
        local git_merge_branch="$(git branch --no-color --contains "$git_merge_head")"
        local git_merge_name=''
        if [ "$git_merge_branch" ]; then
            # remove '*' and leading whitespace from branch name
            git_merge_name="${git_merge_branch/\*/ }"
            git_merge_name="${git_merge_name#"${git_merge_name%%[![:space:]]*}"}"
        else
            git_merge_name="${git_merge_head:0:8}"
        fi
        echo "$GS_SYM_MERGE$(gs_color "$GS_COLOR_MERGE" "$git_merge_name")"
    fi
}

# arguments
# $1 - git base directory
function rs_git_bisect() {
    local git_dir="$1"
    if [ -f "$git_dir/BISECT_START" ]; then
        local git_bisect_start="$(cat "$git_dir/BISECT_START")"
        echo "$GS_SYM_BISECT$(gs_color "$GS_COLOR_BISECT" "$git_bisect_start")"
    fi
}

# combine local status into a string
# arguments:
# $1 - git base directory
# $2 - git granch line from `git status --porcelain --branch`, without the leading "## "
function rs_git_local_status() {
    local git_dir="$1"
    local git_num_staged=0
    local git_num_modified=0
    local git_num_conflict=0
    local git_num_untracked=0
    local IFS=''
    while read -r line; do
        XY=${line:0:2}
        case "$XY" in
            U?)     ((git_num_conflict++)) ;;  # unmerged
            ?U)     ((git_num_conflict++)) ;;  # unmerged
            DD)     ((git_num_conflict++)) ;;  # unmerged (both deleted)
            AA)     ((git_num_conflict++)) ;;  # unmerged (both added)
            ?[MDT]) ((git_num_modified++)) ;;  # modified/deleted/typechange in working tree
            \?\?)   ((git_num_untracked++)) ;; # untracked in index and working tree
        esac
        case "$XY" in
            [MARCD]?) ((git_num_staged++)) ;; # modified/added/renamed/copied/deleted in index
        esac
    done <<< "$2"

    local git_staged=$(rs_format_count "$git_num_staged" "$GS_COLOR_STAGED" "$GS_SYM_STAGED")
    local git_modified=$(rs_format_count "$git_num_modified" "$GS_COLOR_MODIFIED" "$GS_SYM_MODIFIED")
    local git_untracked=$(rs_format_count "$git_num_untracked" "$GS_COLOR_UNTRACKED" "$GS_SYM_UNTRACKED")
    local git_conflict=$(rs_format_count "$git_num_conflict" "$GS_COLOR_CONFLICT" "$GS_SYM_CONFLICT")

    local git_stashed=$(rs_git_stash)
    local git_backup_refs=$(rs_git_backup_refs)
    local git_rebase=$(rs_git_rebase "$git_dir")
    local git_merge=$(rs_git_merge "$git_dir")
    local git_bisect=$(rs_git_bisect "$git_dir")

    local git_stat_arr=($git_rebase $git_merge $git_bisect $git_conflict $git_backup_refs $git_staged $git_modified $git_stashed $git_untracked)
    local git_local_status=$(gs_join ' ' "${git_stat_arr[@]}")
    if [[ ! -z "${git_local_status// }" ]]; then
        echo "$git_local_status"
    else
        echo "$(gs_color "$GS_COLOR_LOCAL_OK" "$GS_SYM_LOCAL_OK")"
    fi
}

# return local branch/tag/commit and remote branch if it exists
# arguments:
# $1 - git granch line from `git status --porcelain --branch`, without the leading "## "
function rs_git_head_origin() {
    local git_head=''
    if [[ "$1" =~ Initial\ commit\ on\ (.+) ]]; then
        # "Initial commit on master" - local branch only
        # "Initial commit on master...origin/master" - checked out empty repo
        echo "$GS_SYM_BRANCH$(gs_color "$GS_COLOR_BRANCH" "${BASH_REMATCH[1]%%...*}")"
    elif [[ "$1" =~ no\ branch ]]; then
        # "HEAD (no branch)" - on tag or detached on commit
        local git_tag=$(git describe --exact-match 2>/dev/null)
        if [ -n "$git_tag" ]; then
            echo "$GS_SYM_TAG$(gs_color "$GS_COLOR_TAG" "$git_tag")"
        else
            local git_commit_hash=$(git rev-parse --short HEAD)
            echo "$GS_SYM_HASH$(gs_color "$GS_COLOR_HASH" "$git_commit_hash")"
        fi
    else
        # "master...origin/master [gone]"
        # "master...origin/master [ahead 8]"
        # "master...origin/master [behind 12]"
        # "master...origin/master [ahead 1, behind 7]"
        local git_branch_arr=(${1//.../ })
        local git_branch="$GS_SYM_BRANCH$(gs_color "$GS_COLOR_BRANCH" "${git_branch_arr[0]}")"
        local git_branch_nocolor="${git_branch_arr[0]}"
        local git_origin="${git_branch_arr[1]}"
        # git branches can't contain spaces, so this should be relatively safe
        echo "$git_branch $git_branch_nocolor $git_origin"
    fi
}

# arguments:
# $1 - local git branch
function rs_git_reviewid() {
    local git_reviewboard_id=$(git config --get branch.$1.reviewid)
    if [ "$?" -eq 0 ]; then
        echo " (rb$(gs_color "$GS_COLOR_REVIEWID" "$git_reviewboard_id"))"
    fi
}

# arguments:
# $1 - local git branch
# $2 - origin branch that is tracking the local branch (if it exists)
function rs_git_remote_status() {
    local git_head="$1"
    local git_origin="$2"
    local git_upstream="${2/origin/upstream}"
    if [[ -z "$git_origin" ]]; then
        # local branch with no remote tracking
        local git_excludes=''
        local git_remote_branches=$(git branch -r)
        if [ -n "$git_remote_branches" ]; then
            local git_remotes_arr=($git_remote_branches)
            local git_excludes_arr=()
            for r in "${git_remotes_arr[@]}"; do
                if [[ "$r" != "->" ]]; then
                    git_excludes_arr+=("^$r")
                fi
            done
            git_excludes=$(gs_join ' ' "${git_excludes_arr[@]}")
        fi
        # figure out how many commits exist on this branch that are not in the remotes
        local git_local_commits=$(git rev-list --count HEAD ${git_excludes} 2>/dev/null)
        if [ -n "$git_local_commits" ] && [ "$git_local_commits" -gt 0 ]; then
            local git_remote_status="$(gs_color "$GS_COLOR_NEED_PUSH_UNTRACKED" "$git_local_commits")$GS_SYM_NEED_PUSH_UNTRACKED"
        else
            local git_remote_status=$(gs_color "$GS_COLOR_NO_REMOTE" "$GS_SYM_NO_REMOTE")
        fi
        echo "$git_remote_status"
    else
        # remote tracking branch
        local git_rev_list_origin=$(git rev-list --count --left-right ${git_head}...${git_origin} 2>/dev/null)
        if [ "$?" -eq 0 ] && [ -n "$git_rev_list_origin" ]; then
            local git_origin_arr=($git_rev_list_origin) # will split into array because it's 2 numbers separated by spaces
            local git_ahead=$(rs_format_count "${git_origin_arr[0]}" "$GS_COLOR_NEED_PUSH" "$GS_SYM_NEED_PUSH")
            local git_behind=$(rs_format_count "${git_origin_arr[1]}" "$GS_COLOR_NEED_PULL" "$GS_SYM_NEED_PULL")
        fi
        git_rev_list_upstream=$(git rev-list --count --left-right ${git_origin}...${git_upstream} 2>/dev/null)
        if [ "$?" -eq 0 ]; then
            local git_upstream_arr=($git_rev_list_upstream) # will split into array because it's 2 numbers separated by spaces
            local git_fork_ahead=$(rs_format_count "${git_upstream_arr[0]}" "$GS_COLOR_FORK_AHEAD" "")
            local git_fork_behind=$(rs_format_count "${git_upstream_arr[1]}" "$GS_COLOR_FORK_BEHIND" "")
            if [ "$git_fork_ahead" ] || [ "$git_fork_behind" ]; then
                local git_fork_status="${git_fork_ahead}$GS_SYM_FORK${git_fork_behind}"
            fi
        fi

        if [ "$git_behind" ] || [ "$git_ahead" ] || [ "$git_fork_status" ]; then
            local git_remote_stat_arr=($git_behind $git_ahead $git_fork_status)
            local git_remote_status=$(gs_join ' ' "${git_remote_stat_arr[@]}")
        else
            # all sync-ed up
            local git_remote_status=$(gs_color "$GS_COLOR_REMOTE_OK" "$GS_SYM_REMOTE_OK")
        fi
        echo "$git_remote_status"
    fi
}

function rs_svn_local_status() {
    local svn_status=$(svn status 2>/dev/null)

    local svn_num_conflicted=0
    local svn_num_added=0
    local svn_num_modified=0
    local svn_num_deleted=0
    local svn_num_locked=0
    local svn_num_history=0
    local svn_num_untracked=0
    local svn_num_external=0
    local svn_num_switched=0
    local svn_num_ignored=0
    local svn_num_missing=0
    local svn_num_obstructed=0
    while IFS='' read -r line; do
        local svn_stat_columns=${line:0:7}
        case "$svn_stat_columns" in
            #  see `svn status --help` for details on these codes
            C??????)  ((svn_num_conflicted++)) ;; # item conflicted
            ?C?????)  ((svn_num_conflicted++)) ;; # file/directory properties conflicted
            ??????C)  ((svn_num_conflicted++)) ;; # tree conflict
            A??????)  ((svn_num_added++)) ;; # item added
            [MR]??????)  ((svn_num_modified++)) ;; # item modified/replaced
            ?M?????)  ((svn_num_modified++)) ;; # file/directory properties modified
            D??????)  ((svn_num_deleted++)) ;; # item deleted
            \???????)  ((svn_num_untracked++)) ;; # item untracked
            I??????)  ((svn_num_ignored++)) ;; # item ignored
            ??L????)  ((svn_num_locked++)) ;; # working copy directory locked
            ?????K?)  ((svn_num_locked++)) ;; # repository lock token present
            ???+???)  ((svn_num_history++)) ;; # commit will contain addition-with-history
            X??????)  ((svn_num_external++)) ;; # unversioned directory created by externals
            ????X??)  ((svn_num_external++)) ;; # versioned file created by externals
            ????S??)  ((svn_num_switched++)) ;; # item has a switched URL
            \!??????)  ((svn_num_missing++)) ;; # item missing (removed by non-svn command)
            ~??????)  ((svn_num_obstructed++)) ;; # item obstructed by some item of a different kind
        esac
    done <<< "$svn_status"

    local svn_conflicted=$(rs_format_count "$svn_num_conflicted" "$RS_COLOR_SVN_CONFLICTED" "$RS_SYM_SVN_CONFLICTED")
    local svn_added=$(rs_format_count "$svn_num_added" "$RS_COLOR_SVN_ADDED" "$RS_SYM_SVN_ADDED")
    local svn_modified=$(rs_format_count "$svn_num_modified" "$RS_COLOR_SVN_MODIFIED" "$RS_SYM_SVN_MODIFIED")
    local svn_deleted=$(rs_format_count "$svn_num_deleted" "$RS_COLOR_SVN_DELETED" "$RS_SYM_SVN_DELETED")
    local svn_locked=$(rs_format_count "$svn_num_locked" "$RS_COLOR_SVN_LOCKED" "$RS_SYM_SVN_LOCKED")
    local svn_history=$(rs_format_count "$svn_num_history" "$RS_COLOR_SVN_ADD_HISTORY" "$RS_SYM_SVN_ADD_HISTORY")
    local svn_untracked=$(rs_format_count "$svn_num_untracked" "$RS_COLOR_SVN_UNTRACKED" "$RS_SYM_SVN_UNTRACKED")
    local svn_external=$(rs_format_count "$svn_num_external" "$RS_COLOR_SVN_EXTERNAL" "$RS_SYM_SVN_EXTERNAL")
    local svn_switched=$(rs_format_count "$svn_num_switched" "$RS_COLOR_SVN_SWITCHED" "$RS_SYM_SVN_SWITCHED")
    local svn_ignored=$(rs_format_count "$svn_num_ignored" "$RS_COLOR_SVN_IGNORED" "$RS_SYM_SVN_IGNORED")
    local svn_missing=$(rs_format_count "$svn_num_missing" "$RS_COLOR_SVN_MISSING" "$RS_SYM_SVN_MISSING")
    local svn_obstructed=$(rs_format_count "$svn_num_obstructed" "$RS_COLOR_SVN_OBSTRUCTED" "$RS_SYM_SVN_OBSTRUCTED")

    local svn_stat_arr=($svn_conflicted $svn_added $svn_modified $svn_deleted $svn_locked $svn_history $svn_untracked $svn_external $svn_switched $svn_ignored $svn_missing $svn_obstructed)
    echo "$(gs_join ' ' "${svn_stat_arr[@]}")"
}

# show info about what kind of repo we're in
# some code and ideas from:
# - http://zanshin.net/2012/03/09/wordy-nerdy-zsh-prompt/
# - https://github.com/sjl/oh-my-zsh/commit/3d22ee248c6bce357c018a93d31f8d292d2cb4cd
# - https://github.com/magicmonty/bash-git-prompt
function repo_status() {
    rs_status=''
    # git
    git_status_porcelain=$(git status --porcelain --untracked-files=normal --branch 2>/dev/null)
    if [ "$?" -eq 0 ]; then
        gs_remote_update_async
        local gs_git=$(gs_color "$GS_COLOR_GIT" "$GS_SYM_GIT")
        local git_dir=$(git rev-parse --git-dir)
        local git_branch_info=$(rs_parse_branch_line "$git_status_porcelain")
        local git_branch_arr=( $(rs_git_head_origin "$git_branch_info") )
        local git_head="${git_branch_arr[0]}"
        local git_head_nocolor="${git_branch_arr[1]}"
        local git_origin="${git_branch_arr[2]}"
        local git_reviewid=$(rs_git_reviewid "$git_head_nocolor")
        local git_remote_status=$(rs_git_remote_status "$git_head_nocolor" "$git_origin")
        local git_local_status=$(rs_git_local_status "$git_dir" "$git_status_porcelain")
        rs_status+="  $gs_git$git_head$git_reviewid $git_remote_status / $git_local_status"
    fi
    # svn
    rs_svn=$(gs_color "$RS_COLOR_SVN" "$RS_SYM_SVN")
    rs_svn_info=$(svn info 2>&1)
    if [ "$?" -eq 0 ]; then
        # TODO: split URI and path with something like '/'
        if [[ "$rs_svn_info" =~ URL:\ ([^$'\n']+) ]]; then
            svn_url="${BASH_REMATCH[1]}"
            svn_protocol=$(expr "$svn_url" : '\([a-z]\+://\)') # match the svn:// or https:// from the start of the repo
            svn_path="$RS_SYM_SVN_REPO_PATH$(gs_color "$RS_COLOR_SVN_PATH" "${svn_url#$svn_protocol}")"
        else
            svn_path=$(gs_color "$RS_COLOR_SVN_PATH" "$RS_SYM_SVN_UNKNOWN_URL")
        fi
        if [[ "$rs_svn_info" =~ Revision:\ ([0-9]+) ]]; then
            svn_revision="$RS_SYM_SVN_REV$(gs_color "$RS_COLOR_SVN_REV" "${BASH_REMATCH[1]}")"
        fi

        local svn_local_status=$(rs_svn_local_status)

        rs_status+="  $rs_svn$svn_path$svn_revision $svn_local_status"
    elif [ "$?" -eq 1 ]; then
        # TODO: break these into an error function
        if [[ "$rs_svn_info" =~ svn:\ E155021 ]]; then
            if [[ "$rs_svn_info" =~ \(format\ ([0-9]+)\) ]]; then
                svn_repo_format="${BASH_REMATCH[1]}"
            else
                svn_repo_format="?"
            fi
            svn_version=$(svn --version --quiet)
            svn_error="$RS_SYM_SVN_ERROR$(gs_color "$RS_COLOR_SVN_ERROR" " client too old (client: $svn_version, repo format: $svn_repo_format)")"
            rs_status+="  $rs_svn$svn_error"
        elif [[ "$rs_svn_info" =~ svn:\ E155036 ]]; then
            if [[ "$rs_svn_info" =~ \(format\ ([0-9]+) ]]; then
                svn_repo_format="${BASH_REMATCH[1]}"
            else
                svn_repo_format="?"
            fi
            svn_version=$(svn --version --quiet)
            svn_error="$RS_SYM_SVN_ERROR$(gs_color "$RS_COLOR_SVN_ERROR" " working copy too old (client: $svn_version, repo format: $svn_repo_format)")"
            rs_status+="  $rs_svn$svn_error"
        #elif [[ "$rs_svn_info" =~ svn:\ (E[0-9]+) ]]; then
        #    svn_error_code="${BASH_REMATCH[1]}"
        #    svn_error="$RS_SYM_SVN_ERROR$(gs_color "$RS_COLOR_SVN_ERROR" " unknown svn error: $svn_error_code")"
        #    rs_status+="  $rs_svn$svn_error"
        fi
    fi
    echo -e "$rs_status"
}

